#!/bin/bash

# used in a ForceCommand inside a "Match All" block in /etc/ssh/sshd_config

svn_log=/var/log/svn.log

readonly \
bad_cmd_msg="This key can only be used for 'snap' operations."

readonly tmp_dir=/tmp/$LOGNAME		# might not exist ...
env | sort > $tmp_dir/repo-serve.env 2>/dev/null # ... so ignore errors

# if client wants rsync service, it could be from snap or generic rsync command
if [[ ${SSH_ORIGINAL_COMMAND-} == 'rsync --server '* ]]
   then [[ $UID == 0 ]] && { exec $SSH_ORIGINAL_COMMAND; exit $?; }
	dest=${SSH_ORIGINAL_COMMAND##* . }
	dest_dir=${dest%%/*}
	case $dest_dir in
	   ( [A-Z][A-Z]* | Ju )		# looks like a snap project name?
		;;			# next case statement will process it
	   ( * )
		exec $SSH_ORIGINAL_COMMAND # else generic rsync command
		exit $? ;;
	 esac
fi

umask 02			   # we use group permissions in data projects

case ${SSH_ORIGINAL_COMMAND-} in
   ( 'snap '* | 'rsync --server '* )	# these patterns duplicated in snapserv
	# can add -t option, to output "set -x" to ~snap/.snapserv.log.dbg
	exec /usr/local/bin/snapserv $SSH_ORIGINAL_COMMAND
	exit 1 ;;
   ( svnserve* )
	exec /usr/bin/svnserve --tunnel --log-file $svn_log \
			       --root=/var/repos/svn "$@"
	exit 1 ;;
   ( * )
	if [[ ${HRDAG_KEY-} != snap ]]
	   then if [[ ${SSH_ORIGINAL_COMMAND-} ]]
		   then exec $SSH_ORIGINAL_COMMAND
			exit $?
		elif [[ ${SSH_TTY-} || ${TERM-} ]] # want interactive shell?
		   then exec bash -i
			exit $?
		   else exit 0		# probably SSH tunnel
		fi
	fi

	echo -e "\n  $bad_cmd_msg\n"
	source /etc/martus/prologue.sh
	file=$tmpdir/$our_name-$(date -I)
	{ header $(date); env | sort; } >> $file
	sleep 3				# so PuTty has time to see it
	exit 1 ;;
esac
